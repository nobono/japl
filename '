# ---------------------------------------------------
from typing import Callable
from typing import Generator
from typing import Optional

from tqdm import tqdm

import numpy as np

from japl.SimObject.SimObject import SimObject

from scipy.integrate import solve_ivp

from functools import partial

# ---------------------------------------------------

from matplotlib import patches
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
from matplotlib.animation import FuncAnimation
from matplotlib.lines import Line2D



class Sim:

    def __init__(self,
                 t_span: list|tuple,
                 dt: float,
                 simobjs: list[SimObject],
                 events: list = [],
                 anim_solve: bool = False,
                 ) -> None:
        self.t_span = t_span
        self.dt = dt
        self.simobjs = simobjs
        self.events = events
        self.anim_solve = anim_solve # choice of iterating solver over each dt step

        # setup time array
        self.istep = 0
        self.Nt = int(self.t_span[1] / self.dt)
        self.t_array = np.linspace(self.t_span[0], self.t_span[1], self.Nt + 1)

    # def _setup(self):

    #     simobj = self.simobjs[0]
    #     # x0 = simobj.X0

    #     # setup time array
    #     Nt = int(self.t_span[1] / self.dt)
    #     t_array = np.linspace(self.t_span[0], self.t_span[1], Nt)

    #     # pre-allocate output arrays
    #     # simobj.T = np.zeros(t_array.shape)
    #     simobj.T = t_array
    #     simobj.Y = np.zeros((t_array.shape[0], simobj.X0.shape[0]))

    #     # initial state outputs
    #     simobj.T[0] = self.t_span[0]
    #     simobj.Y[0] = simobj.X0


    def step(self, t, X, simobj):
        ac = np.array([3*np.cos(2 * t), .5*np.sin(1 * t), 0])

        fuel_burn = X[6]
        if fuel_burn >= 100:
            ac = np.zeros((3,))

        burn_const = 0.4

        U = np.array([*ac])
        Xdot = simobj.step(X, U)
        Xdot[6] = burn_const * np.linalg.norm(ac)

        return Xdot



    def __call__(self):

        simobj = self.simobjs[0]

        ################################
        # solver
        ################################

        if not self.anim_solve:
            sol = solve_ivp(
                    fun=self.step,
                    t_span=self.t_span,
                    t_eval=self.t_array,
                    y0=simobj.X0,
                    args=(simobj,),
                    events=self.events,
                    rtol=1e-3,
                    atol=1e-6,
                    max_step=0.2,
                    )
            simobj.T = sol['t']
            simobj.Y = sol['y'].T

        ################################
        # solver for one step at a time
        ################################

        elif self.anim_solve:

            # pre-allocate output arrays
            simobj.T = np.zeros((self.Nt, ))
            simobj.Y = np.zeros((self.Nt, len(simobj.X0)))

            self.fig, self.ax = plt.subplots(figsize=(6, 4))

            self.ax.set_aspect("equal")

            # add simobj patch to Sim axes
            self.ax.add_patch(simobj.patch)
            self.ax.add_line(simobj.trace)

            anim = FuncAnimation(
                    self.fig,
                    partial(self.animate, _simobj=simobj),
                    frames=partial(self.frames, _simobj=simobj),
                    interval=1,
                    blit=False,
                    cache_frame_data=False
                    )

            plt.show()


    def animate(self, frame, _simobj: SimObject):
        t, y = frame

        _simobj.trace.set_data(_simobj.T[:self.istep], _simobj.Y[:self.istep, 1])

        xdata = t
        ydata = y[1]

        _simobj.patch.set_center((xdata, ydata))

        xmargin = .1
        ymargin = .1
        xlim = self.ax.get_xlim()
        ylim = self.ax.get_ylim()

        if xdata - xlim[1] + xmargin > 0:
            self.ax.set_xlim([xlim[0], xdata + xmargin])
        if xdata - xlim[0] - xmargin < 0:
            self.ax.set_xlim(([xdata - xmargin, xlim[1]]))

        if ydata - ylim[1] + ymargin > 0:
            self.ax.set_ylim([ylim[0], ydata + ymargin])
        if ydata - ylim[0] - ymargin < 0:
            self.ax.set_ylim([ydata - ymargin, ylim[1]])

        # xlim = self.ax.get_xlim()
        # ylim = self.ax.get_ylim()
        # xrange = np.abs(xlim[1] - xlim[0])
        # yrange = ylim[1] - ylim[0]

        # RANGE_LOCK = 3
        # if xrange > RANGE_LOCK:
        #     diff = (np.abs(xdata - xlim[0]) + np.abs(xdata - xlim[1]) - RANGE_LOCK) / 2
        #     self.ax.set_xlim([xlim[0] + diff, xlim[1] + diff])
        # if yrange > RANGE_LOCK:
        #     diff = (np.abs(ydata - ylim[0]) + np.abs(ydata - ylim[1]) - RANGE_LOCK) / 2
        #     self.ax.set_ylim([ylim[0] + diff, ylim[1] - diff])
        # if yrange < -RANGE_LOCK:
        #     diff = (np.abs(ydata - ylim[0]) + np.abs(ydata - ylim[1]) + RANGE_LOCK) / 2
        #     self.ax.set_ylim([ylim[0] - diff, ylim[1] - diff])

        return [_simobj.patch, _simobj.trace]


    def frames(self, _simobj: SimObject):
        """passes frame data to FuncAnimation.
        Take SimObject and returns iterable of matplotlib artist"""

        while self.istep < self.Nt - 1:
            self.istep += 1
            self._anim_update(self.istep, _simobj)
            # yield (_simobj.T[:self.istep], _simobj.Y[:self.istep]) # trace data
            yield (_simobj.T[self.istep], _simobj.Y[self.istep]) # center data

        # on animate end
        if "time_slider" not in dir(self):
            axis_position = plt.axes([0.2, 0.01, 0.65, 0.03], facecolor='white') # type:ignore
            self.time_slider = Slider(
                axis_position,
                label='Time (s)',
                valmin=0,
                valmax=self.Nt - 1,
                valinit=0
                )
            self.time_slider.on_changed(lambda t: self._time_slider_update(t, _simobj=_simobj))


    def _anim_update(self, istep: int, _simobj: SimObject, rtol: float = 1e-6, atol: float = 1e-6) -> None:
        """This method is an update step for the ODE solver from time step 't' to 't + dt';
        used by FuncAnimation. Data generated by this method:
            t - time array of solution points
            y - (Nt x N_state) array of the solution points of the ODE"""
        tstep_prev = self.t_array[istep]
        tstep = tstep_prev + self.dt
        x0 = _simobj.Y[istep - 1]

        sol = solve_ivp(
                fun=self.step,
                t_span=(tstep_prev, tstep),
                t_eval=[tstep],
                y0=x0,
                args=(_simobj,),
                events=self.events,
                rtol=rtol,
                atol=atol,
                )
        _simobj.T[istep] = sol['t'][0]
        _simobj.Y[istep] = sol['y'].T[0]

    def _time_slider_update(self, val: float, _simobj: SimObject) -> None:

        # get data range
        val = int(val)
        t = _simobj.T[:val]
        y = _simobj.Y[:val]

        # select user specficied state(s)
        state_select = 0
        xdata = t
        ydata = y[:, state_select]

        # update artist data
        _simobj.patch.set_center((xdata[-1], ydata[-1]))
        _simobj.trace.set_data(xdata[:val], ydata[:val])


